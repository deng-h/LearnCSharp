namespace 数据结构与算法_哈希函数与哈希表
{
    /*
     * 哈希函数 y=f(x) 认为输入是无穷的 x∈X，输出是有穷的 y∈Y 如MD5，SHA1都是哈希函数模型
     * 相同的输入一定会得到相同的输出，不同的输入可能会得到相同的输出，但是概率很小，也叫哈希碰撞
     * 当哈希函数的输出模上m，则输出结果在0~m-1之间均匀分布，这样就可以用来做哈希表的下标
     * 在C#中，哈希函数的实现是通过GetHashCode()方法，它是Object类的一个方法，所有的类都继承自Object类
     * 
     * 哈希表 基于哈希函数实现的数据结构，哈希表的底层是一个数组，数组的每个元素是一个长长的链表
     * 某个任意值经过哈希函数得到的结果模上m就是数组的下标，然后将该值插入到该下标对应的链表中
     * --------
     * |  1   |  -> data1 -> data2 -> ...
     * --------
     * |  2   |  -> data3 -> data4 -> ...
     * --------
     * |  3   |  -> data5 -> data6 -> ...
     * --------
     * |  4   |  -> data7 -> data8 -> ...
     * --------
     */
    internal class Program
    {
        static void Main(string[] args)
        {
            Dictionary<string, int> dic = new();
            dic.Add("a", 1);
        }

        // 布隆过滤器，有几率"错杀"，但是不会"漏网"
        // 一个很长的二进制向量(位图)和一系列随机映射函数(也就是哈希函数)，用于检测一个元素是否在一个集合中
        // 优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难
        // 例如：在垃圾邮件过滤器中，如果一个邮件被布隆过滤器认为是垃圾邮件，那么这个邮件不一定是垃圾邮件
        // 但是如果一个邮件被布隆过滤器认为不是垃圾邮件，那么这个邮件一定不是垃圾邮件
        // 也就是说，布隆过滤器可以用来检测一个元素是否在一个集合中，但是不能用来检测一个元素不在一个集合中
        // 例如：在网站的黑名单中，如果一个IP被布隆过滤器认为是黑名单，那么这个IP不一定是黑名单
        // 但是如果一个IP被布隆过滤器认为不是黑名单，那么这个IP一定不是黑名单
        // 一个只包含0和1的数组，长度为m，每个元素都是一个bit，每个bit只能是0或者1
        // 一个包含k个哈希函数的集合，每个哈希函数都可以将任意长度的输入映射到[0, m-1]的某个整数
        // 例如：哈希函数1可以将任意长度的输入映射到[0, m-1]的某个整数，哈希函数2可以将任意长度的输入映射到[0, m-1]的某个整数
        // 例如：哈希函数3可以将任意长度的输入映射到[0, m-1]的某个整数，哈希函数4可以将任意长度的输入映射到[0, m-1]的某个整数
        // 然后将这4个整数对应的bit置为1 哈希函数1得到的整数是3，哈希函数2得到的整数是5，哈希函数3得到的整数是7，哈希函数4得到的整数是9
        // 此时新来一个数据，如果经过k个哈希函数得到的4个整数对应的bit都是1，那么就认为这个数据在集合中，反之则认为这个数据不在集合中
        // 由黑名单构造的布隆过滤器，当一个黑名单进来时肯定能判断为是黑名单里的，但是当一个不在黑名单里的IP进来时，有可能会判断为在黑名单里
        // n=样本量，p=误判率，m=位数组长度，k=哈希函数个数
        // m = (n * ln(p)) / (ln2)^2
        // k = ln2 * (m / n) / 0.7 * (m / n)


    }
}
